Guia de Projeto: Campeonato Web (Next.js, Shadcn/UI, Tailwind, Supabase)
Este guia fornece um passo a passo completo para construir uma aplicação web de campeonato entre dois grupos (RAC e AST) que competem em 5 jogos diferentes (R6, LoL, CS, Brawlhalla, Valorant). O projeto utiliza Next.js no front-end com shadcn/ui e Tailwind CSS, e Supabase (PostgreSQL) como back-end. Incluímos também autenticação via Supabase Auth com três usuários fixos (admin_super, admin_rac, admin_ast) e considerações de deploy na Vercel. O objetivo é apresentar um TODO README detalhado, para que o desenvolvimento possa ser seguido sequencialmente, sem ambiguidades.
1. Etapas do Projeto (Todo List)
1. Configuração do Ambiente e Projeto Base
2. Instale Node.js (versão LTS atual) e PNPM/NPM se necessário.
3. Crie um novo projeto Next.js (com TypeScript) e Tailwind CSS. Você pode usar o template oficial da Vercel com Supabase que já inclui Tailwind:

  npx create-next-app@latest --example with-supabase campeonato-rac-ast
  Esse template with-supabase já vem pré-configurado com Tailwind e autenticação de cookies do Supabase.
4. Alternativamente, crie com create-next-app padrão e configure Tailwind manualmente:
o npx create-next-app@latest campeonato-rac-ast --typescript
o Siga a documentação Tailwind para configurar (instalar tailwindcss e gerar tailwind.config.js e globals.css).
o Instale o cliente Supabase: npm install @supabase/supabase-js.
5. Inicialize um repositório Git e faça commit inicial do projeto.
6. Instalação e Configuração do shadcn/ui
7. Instale o utilitário do shadcn/ui:

  npx shadcn-ui@latest init
  (Ou usando PNPM: pnpm dlx shadcn@latest init).
8. Configure o shadcn/ui conforme a documentação: escolha Next.js e o diretório de componentes padrão (por exemplo, components/ui).
9. Instale os componentes UI necessários via CLI do shadcn. Por exemplo, instale componentes básicos como Button, Input, Card, Table, etc., que serão úteis na interface:

  npx shadcn-ui@latest add button input card table
10. Verifique se os estilos do shadcn/ui estão importados no CSS global (o shadcn usa Tailwind, certifique-se de incluir as diretivas de estilo conforme a doc).
11. Teste renderizar um componente básico (por exemplo, um botão do shadcn) na página inicial para garantir que está tudo funcionando.
12. Configuração do Supabase (Backend)
13. Crie um projeto no Supabase e obtenha as chaves API:
o Project URL e Public Anon Key (para o cliente).
o Database URL e Service Role Key (se necessário para operações de admin, mas evite usar a Service Key no cliente).
14. Configure as variáveis de ambiente no projeto Next.js:
o Crie um arquivo .env.local com as chaves do Supabase:

  NEXT_PUBLIC_SUPABASE_URL=<URL_DO_PROJETO>
NEXT_PUBLIC_SUPABASE_ANON_KEY=<PUBLIC_ANON_KEY>
SUPABASE_SERVICE_ROLE=<SERVICE_ROLE_KEY>  # (se for usar no backend do Next para funções administrativas)
15. No código, configure um cliente Supabase:
o Crie um arquivo utilitário (por exemplo, lib/supabaseClient.ts ou similar) e inicialize o cliente:

  import { createClient } from '@supabase/supabase-js';
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
export const supabase = createClient(supabaseUrl, supabaseAnonKey);
o Esse cliente será usado para chamadas no front-end (ou use diferentes clientes para Server/Edge e Client conforme necessidade).
16. Auth do Supabase: Prepare-se para criar os usuários fixos:
o No dashboard do Supabase, na seção Auth > Users, cadastre manualmente três usuários correspondentes a:
o admin_super (Super Admin geral)
o admin_rac (Admin do time RAC)
o admin_ast (Admin do time AST)
Use emails distintos (ex: admin_super@exemplo.com etc.) e senhas fortes para cada um.
o Opcional: Adicione um campo customizado de perfil/role:
o Crie uma tabela profiles vinculada a auth.users para armazenar roles (ver esquema de BD abaixo) ou utilize os metadados do próprio usuário (app_metadata) para guardar um campo role (ex: "role": "rac").
o Assegure que cada usuário criado receba sua role adequada (ex: admin_rac com role "rac"). Isso pode ser feito via SQL no Supabase (atualizando auth.users.raw_app_meta_data) ou inserindo na tabela de perfis.
o Habilite o envio de email de confirmação ou defina os usuários como confirmados manualmente para poderem logar sem obstáculos (nas configurações de Auth do Supabase).
17. Modelagem do Banco de Dados (Supabase)
18. No Supabase, modele as tabelas conforme os requisitos do campeonato. Você pode usar o Editor de tabelas ou rodar SQL de criação. Veja o esquema completo na seção 2. Esquema do Banco de Dados abaixo para detalhes das tabelas e colunas.
19. Crie todas as tabelas necessárias (teams, players, games, series, matches, match_players, profiles, etc.) e defina os relacionamentos (foreign keys) conforme descrito.
20. Popule dados iniciais:
o Tabela teams: insira pelo menos os dois times iniciais (RAC, AST).
o Tabela games: insira os 5 jogos (R6, LoL, CS, Brawlhalla, Valorant).
o Tabela players: cadastre os jogadores conhecidos de cada time (ou deixe para cadastrar via interface admin depois).
21. Habilite Row Level Security (RLS) somente se for necessário restringir acesso. Como apenas admins autenticados irão alterar dados, podemos manter RLS simples (ex.: somente usuários autenticados podem selecionar dados, e talvez só admins podem inserir/atualizar). Crie policies conforme a necessidade:
o Exemplo: permitir SELECT para role anon (caso queira páginas públicas verem dados) ou autenticar todos.
o Permitir INSERT/UPDATE nas tabelas de campeonato apenas para usuários admin (pode filtrar pelo profile.role).
o Atenção: Se optar por RLS, associe as roles do app (admin_super, admin_rac, admin_ast) aos usuários e use essas informações nas policies.
22. Desenvolvimento das Páginas e Rotas
23. Configure as rotas/pages no Next.js. Considerando Next 13+, recomenda-se usar o App Router (app/ directory) para organizar as páginas:
o Pública: Home (app/page.tsx)
o Pública: Jogos/Series (app/jogos/page.tsx ou similar)
o Pública: Partidas (app/partidas/page.tsx)
o Pública: Times (app/times/page.tsx)
o Protegida: Admin (app/admin/page.tsx e possivelmente sub-rotas ou componentes)
o Pública: Login (app/login/page.tsx)
24. Implemente o design e conteúdo de cada página (veja a descrição detalhada de cada página na seção 4. Páginas do Sistema):
o Use os componentes do shadcn/ui para construir formulários, tabelas de ranking e layout consistente (por exemplo, utilizar componentes de Card, Table, Input, Button, etc. para estilizar).
o Utilize Tailwind CSS utilitariamente para ajustar espaçamento, cores, etc., garantindo responsividade.
25. Configure a navegação (ex.: um menu ou barra de navegação no layout principal) com links para Home, Jogos, Partidas, Times, Admin (se logado), e Logout/Login conforme o estado de autenticação.
26. Implementação da Autenticação e Proteção de Rotas
27. Na página de Login, implemente um formulário de login (email e senha) utilizando Supabase Auth:
o Use supabase.auth.signInWithPassword({ email, password }) para autenticar.
o Trate erros (exibir mensagem se credenciais inválidas).
o Ao logar, guarde o estado do usuário (Supabase retorna sessão JWT). Como o template with-supabase usa cookies, o estado pode estar acessível via SSR; caso contrário, utilize contexto ou um hook (por exemplo, useUser do @supabase/auth-helpers-react se instalado) para rastrear o usuário logado.
28. Adicione lógica de proteção de rotas:
o Com App Router, você pode usar Middleware (middleware.ts) para redirecionar usuários não autenticados tentando acessar /admin de volta para /login. Alternativamente, verifique no componente do page Admin se o usuário está logado e role apropriada, caso contrário redirect('/login').
o Diferencie privilégios:
o Permita acesso ao Admin geral apenas para admin_super. Caso admin_rac ou admin_ast logue e tente acessar áreas não permitidas, pode ocultar ou bloquear (ex: eles poderiam acessar somente sub-páginas de editar lineup do próprio time, etc., se implementado).
o Nas páginas públicas, nenhum login é exigido (apenas leitura de dados abertos).
29. Implemente botão Logout (pode ficar no canto superior, visível quando logado):
o Chame supabase.auth.signOut() e redirecione para Home ou Login.
o Limpe qualquer estado local de usuário.
30. Funcionalidades de Admin (CRUD Campeonato)
31. Na página Admin, apresente opções para as ações administrativas (ver seção 6. Ações do Admin para detalhes). Isso pode ser um menu interno ou seções distintas:
o Cadastrar novo confronto (série de jogo) entre RAC e AST.
o Registrar resultados das partidas de uma série.
o Gerenciar lineups e jogadores (cadastrar/editar jogadores, atribuí-los aos times, etc.).
32. Implemente formulários e componentes necessários para essas ações:
o Formulário para criar série: selecionar jogo (dropdown dos 5 jogos da tabela games), definir data/hora (opcional), talvez local ou observações. Como são sempre os mesmos dois times (RAC vs AST), não precisa selecionar times.
o Tela/Seção para listar séries existentes e inserir partidas para cada série:
o Por exemplo, ao clicar em um confronto (LoL, R6, etc.), ir para uma tela de detalhe ou expandir mostrar partidas.
o Form de adicionar partida: selecionar qual série, escolher qual time venceu, selecionar jogadores participantes de cada lado (multi-seleção de players da equipe RAC e AST) e opção de marcar um jogador como MVP.
o Formulário de gerenciamento de jogadores: permitir adicionar novo jogador (nome e time) e editar/remover existentes. Admins de time (admin_rac, admin_ast) podem ficar restritos a gerenciar só os jogadores do seu time; admin_super gerencia ambos.
33. Ao submeter qualquer formulário, use o cliente Supabase para fazer insert/update nas tabelas correspondentes. Atualize a interface após as operações (feedback de sucesso/erro, etc.).
34. Garanta validação básica nos formulários (por exemplo, não permitir partida sem vencedor selecionado, etc.). Utilize bibliotecas como Zod ou validação simples antes de enviar ao Supabase.
35. Cálculo e Exibição dos Rankings
36. Implemente lógica para calcular rankings de forma dinâmica (ver detalhes na seção 7. Regras de Negócio: Cálculo de Rankings):
o Ranking geral de times: calcular pontos totais de cada time baseado nas séries ganhas (vitórias em cada jogo).
o Ranking por jogo: indicar qual time venceu cada um dos jogos específicos (ou, se fosse geral para vários campeonatos, quantas vitórias em cada modalidade, mas no nosso caso cada modalidade é disputada uma vez).
o Ranking de jogadores: calcular número de vitórias por jogador e quantidade de MVPs.
37. Essas métricas podem ser calculadas on the fly no front-end consultando os dados via Supabase:
o Exemplo: para ranking de jogadores, faça um select em players junto com subconsultas/joins em match_players e matches para contar vitórias e MVPs. Ou busque todos os dados necessários (todas partidas e séries) e processe em JavaScript.
38. Exiba os rankings nas páginas adequadas:
o Home: mostrar um resumo do placar geral (ex: "RAC 3 x 2 AST" se terminou, ou placar atual) e possivelmente destaques (ex: jogador com mais MVPs).
o Times: para cada time, mostrar sua pontuação geral e eventualmente lista de jogadores com estatísticas básicas (vitórias/MVPs daquele time).
o Jogos: listar cada jogo (modalidade) e indicar quem venceu aquele confronto e o placar da série (ex: LoL – vencedor RAC por 2-1).
o Partidas: poderia listar cada partida individual e marcar MVP e vencedor. Talvez permitir filtro por jogo ou por série.
39. Formate adequadamente usando componentes UI (por exemplo, uma tabela para rankings, cartões para destaque, etc.).
40. Testes e Deploy
41. Testes Manuais: Navegue por todas as páginas:
o Verifique que usuários não autenticados não acessam /admin.
o Teste login com cada tipo de usuário (admin_super, admin_rac, admin_ast) e cheque se as permissões se comportam (ex: admin_rac não consegue editar jogadores do AST se implementado assim).
o Insira alguns dados de teste: cadastre partidas, confira se os rankings atualizam corretamente.
o Cheque responsividade e compatibilidade nos principais navegadores.
42. Deploy na Vercel:
o Crie um novo projeto no Vercel conectado ao repositório.
o Adicione as variáveis de ambiente no dashboard da Vercel (NEXT_PUBLIC_SUPABASE_URL, NEXT_PUBLIC_SUPABASE_ANON_KEY, etc.).
o Configure a build (a maioria das vezes, Vercel detecta automaticamente Next.js).
o Após deploy, teste novamente as funcionalidades agora no ambiente de produção.
43. Monitore os logs no Supabase e Vercel para garantir que não há erros de requisição ou regras de segurança bloqueando ações.
Com esses passos concluídos, você terá uma aplicação funcional atendendo todos os requisitos. A seguir, detalhamos cada aspecto do sistema para orientar na implementação.
2. Esquema do Banco de Dados (Supabase)
A modelagem do banco no Supabase é crítica para refletir as regras do campeonato. Abaixo está o esquema das tabelas e suas colunas, incluindo chaves primárias (PK), estrangeiras (FK) e observações:
* Tabela teams (Times): Lista os times ou grupos competidores (aqui serão basicamente RAC e AST).
* id (uuid, PK): Identificador único do time.
* name (text): Nome do time (ex: "RAC", "AST"). – Pode ser usado como código do time.
* Campos adicionais opcionais: logo (URL da imagem), descrição, etc. (Não essencial agora).
* Tabela players (Jogadores): Lista de jogadores participantes e a qual time pertencem.
* id (uuid, PK): ID único do jogador.
* name (text): Nome ou nick do jogador.
* team_id (uuid, FK -> teams.id): Referência ao time ao qual o jogador pertence (RAC ou AST). – Define o vínculo do jogador com um grupo.
* Campos adicionais: posição, idade, etc. (Opcional, dependendo do escopo).
* Tabela games (Modalidades/Jogos): Lista os jogos diferentes que compõem o campeonato.
* id (smallint or uuid, PK): ID do jogo/modalidade. Pode ser um código numérico ou uuid.
* name (text): Nome do jogo (ex: "Rainbow Six Siege", "League of Legends", "CS:GO", "Brawlhalla", "Valorant").
* slug (text, único): Um identificador curto, se útil (ex: "R6", "LoL", "CS", etc.).
* Nota: Essa tabela permite flexibilidade para adicionar mais jogos no futuro ou referenciar facilmente cada modalidade.
* Tabela series (Confrontos/Séries de jogos): Representa cada duelo entre RAC e AST em uma determinada modalidade. Cada série é uma disputa best of 3 em um jogo e vale 1 ponto no placar geral.
* id (uuid, PK): ID da série.
* game_id (FK -> games.id): Qual jogo está sendo disputado nesta série.
* date (timestamp/timezone): Data e hora agendada ou realizada da série (opcional, para cronograma).
* winner_team_id (FK -> teams.id, nullable): Qual time venceu a série (preencher após conclusão).
* score_rac (int): Pontos de mapa/partidas vencidas pelo RAC na série (0 a 3).
* score_ast (int): Pontos de mapa/partidas vencidas pelo AST na série (0 a 3).
* is_completed (bool): Indica se a série foi concluída. Poderia ser derivado de winner, mas explícito para clareza.
* Restrições: Como é sempre RAC vs AST, não há campos de team diretamente aqui; implicitamente sabemos que os competidores são esses dois times fixos. Os campos de score ajudam a registrar se foi 2x0, 2x1, etc.
* Tabela matches (Partidas individuais): Armazena cada partida individual dentro de uma série. Por exemplo, em uma série de LoL melhor de 3, poderemos ter até 3 registros de partidas.
* id (uuid, PK): ID da partida.
* series_id (FK -> series.id): Referência à série a que essa partida pertence.
* match_number (int): Número da partida dentro da série (1, 2 ou 3).
* winner_team_id (FK -> teams.id): Time vencedor dessa partida. (RAC ou AST).
* mvp_player_id (FK -> players.id, nullable): Jogador eleito MVP na partida (pode ser nulo se não houve ou não foi escolhido).
* note (text, opcional): Campo para observações (ex: placar específico, destaque, etc. se aplicável).
* Relacionamentos & Dependências: O preenchimento de winner_team_id deve coincidir com um dos times da série (RAC ou AST). Quando partidas são inseridas, podemos atualizar os scores da série associada:
o Por exemplo, incrementar score_rac ou score_ast na tabela series conforme o vencedor, para manter contagem.
* Tabela match_players (Participação de jogadores nas partidas): Tabela de ligação (join table) entre matches e players para registrar quais jogadores jogaram cada partida.
* match_id (FK -> matches.id, PK composta*): Referência à partida.
* player_id (FK -> players.id, PK composta*): Referência a um jogador que participou.
* A PK pode ser composta por (match_id, player_id) para não repetir combinações.
* team_id (FK -> teams.id): Redundante talvez, mas pode armazenar o time do jogador para facilitar queries. (Ou derivar via players->team_id).
* Uso: Permite listar quais jogadores de cada lado jogaram em determinada partida. Ao cadastrar a partida, o admin selecionará de 5 a X jogadores de cada lado (dependendo do jogo; ex: LoL 5x5, Valorant 5x5, CS 5x5, R6 5x5, Brawlhalla talvez 4x4 ou 2x2? Depende, mas se variar, o sistema não precisa validar exato, apenas registrar escolhidos).
* Tabela profiles (Perfis de usuário/admin): (Opcional, mas recomendado para guardar roles dos usuários do sistema)
* id (uuid, PK): ID do perfil (igual ao do usuário do Supabase Auth).
* user_id (uuid, unique, FK -> auth.users.id): Referência para o usuário de autenticação. (No Supabase, pode usar o mesmo ID como PK)
* role (text): Papel do usuário (ex: "super", "rac", "ast").
* team_id (FK -> teams.id, nullable): Se o admin estiver associado a um time (ex: admin_rac associado ao time RAC). Para admin_super pode ser nulo ou apontar para ambos (mas melhor nulo).
* Observação: Podemos não precisar dessa tabela se optarmos por usar auth.users com meta-dados. No entanto, criar uma tabela profiles facilita fazer joins e policies via RLS se necessário, além de guardar dados extras de perfil.
* Tabela migrations ou scripts SQL: (Opcional, somente se for usar migrações de código)
* Como usamos Supabase, podemos manter as migrações controladas ou usar o fonte de verdade no próprio dash. Em projetos colaborativos, versionar SQL de criação das tabelas é útil.
* Exemplo: usar Supabase CLI para gerar migrações após criar as tabelas via interface.
Relações importantes resumidas:
- players.team_id -> teams.id (muitos-para-um: muitos jogadores num time).
- series.game_id -> games.id (muitos confrontos para uma modalidade).
- matches.series_id -> series.id (muitas partidas dentro de um confronto).
- matches.winner_team_id -> teams.id (time vencedor da partida).
- matches.mvp_player_id -> players.id (MVP da partida).
- match_players.match_id -> matches.id, match_players.player_id -> players.id (participantes de partidas).
- profiles.user_id -> auth.users.id, profiles.team_id -> teams.id.
Este esquema permite representar todos os detalhes do campeonato: desde quais jogos existem, quais séries (confrontos) entre os times em cada jogo, até detalhes de cada partida e participação de jogadores, além de suportar o sistema de autenticação/roles dos admins.
3. Regras do Campeonato e Implementação no Código
Antes de codificar, é importante compreender as regras de negócio do campeonato RAC vs AST e como traduzi-las para lógica no sistema:
* Estrutura do Campeonato: Trata-se de um confronto entre dois grupos (RAC e AST) através de uma série de 5 jogos diferentes. Podemos imaginar que seja uma espécie de disputa multi-modalidade:
* Jogos incluídos: R6 (Rainbow Six Siege), LoL (League of Legends), CS (Counter-Strike), Brawlhalla, Valorant.
* Cada jogo representa uma série independente (um confronto específico naquela modalidade).
* O campeonato geral é uma espécie de "melhor de 5 jogos": ou seja, quem vencer mais séries dentre as 5 modalidades será o campeão geral.
* Formato de cada Série (cada jogo/modalidade):
* Cada série é disputada melhor de 3 partidas (best of 3). Isso significa que em cada modalidade, RAC e AST jogarão até 3 partidas contra si:
o Se um time vencer 2 partidas seguidas (2x0), a série pode terminar sem necessidade da 3ª partida.
o Se cada time vencer uma das duas primeiras partidas (ficar 1x1), haverá uma terceira e decisiva partida (2x1).
* Cada vitória de partida dentro da série conta apenas para decidir quem ganha a série daquela modalidade, mas não acumula pontos diretamente no placar geral. Somente a vitória na série (ou seja, levar a modalidade) gera ponto para o time no campeonato geral.
* Implementação:
o Use a tabela matches para registrar cada partida jogada, com seu vencedor e (opcional) MVP.
o Após cada inserção de partida, verificar se a série atingiu um resultado final:
o Ex: se RAC venceu 2 partidas, pode marcar series.winner_team_id = RAC e is_completed = true.
o Ou implementar lógica para só permitir inserir partida 3 se cada time venceu uma antes.
o Essa verificação pode ser feita no front-end (Admin ao inserir dados recebe aviso) e/ou via funções no Supabase (como trigger ou função RPC para fechar série).
o No código Next.js, ao listar ou computar resultados, agrupe partidas por série para determinar o placar daquela série.
* Pontuação do Campeonato (Placar Geral):
* Cada série vencida vale 1 ponto no placar geral do campeonato para o time vencedor daquela modalidade.
* Como são 5 jogos, há 5 pontos em disputa no total. Não há empates porque 5 é ímpar; um time terminará com 3 ou mais pontos contra 2 ou menos do adversário.
* O time com mais pontos ao final (quem vencer pelo menos 3 das 5 modalidades) é o campeão geral.
* Implementação:
o A tabela series armazena quem venceu cada série. Podemos calcular o placar geral contando quantas séries têm winner = RAC e quantas = AST.
o A qualquer momento (especialmente na página Home), o placar geral atual pode ser mostrado como: RAC X AST (ex: 2 x 1 se já houver 3 séries concluídas, etc.).
o Se quiser, marcar campe\u00e3o geral quando uma equipe alcançar 3 vitórias de séries (pode ser um estado exibido na Home - "RAC campeão!" - se applicable).
o Esse cálculo não precisa ser persistido, basta computar dinamicamente (count no banco ou em código).
* Ranking de Times (Geral e por Jogo):
* Geral: Basicamente o placar geral descrito acima. Como só há dois times, o "ranking geral" é trivial – apenas mostra quem está na frente em pontos ou se empatados até o momento. Em campeonatos futuros com mais equipes (caso expandido), o ranking geral ordenaria por pontos.
* Por jogo: Para cada modalidade (jogo), indicar qual time foi o vencedor naquela categoria. Com dois times e uma série por jogo, podemos listar os resultados por jogo. Exemplo:
o LoL: vencedor AST (placar da série 2-1)
o R6: vencedor RAC (placar 2-0)
o etc.
o Se fosse um sistema reutilizável, poderíamos registrar várias séries de um mesmo jogo e ter um ranking de desempenho por jogo (ex: se mais times jogassem, qual time tem mais vitórias naquele jogo). Mas no escopo atual, “ranking por jogo” refere-se apenas ao resultado de cada modalidade nessa disputa específica.
* Implementação:
o Na página Jogos, liste cada entrada da tabela games, e ao lado apresente o resultado: se series.winner_team_id está preenchido para aquela modalidade, mostrar nome do time vencedor e o placar (usar score_rac e score_ast da série para exibir algo como 2x1 ou 2x0).
o Se a série ainda não ocorreu ou não foi concluída, indicar "pendente" ou mostrar data agendada.
o O ranking geral de times pode ser exibido na Home e/ou na página Times:
o Na Home: destaque o placar (por exemplo, um componente mostrando "RAC 3 x 2 AST").
o Em Times: liste os times e suas pontuações (pode ser redundante com apenas dois, mas pensando no futuro ou formato consistente).
* Ranking de Jogadores (Vitórias e MVPs):
* Cada jogador terá estatísticas pessoais:
o Vitórias: Quantidade de partidas em que ele esteve no time vencedor. (Ou poderíamos contar séries vencidas? A descrição diz vitórias, que interpretamos como vitórias em partidas, já que MVP é por partida também.)
o MVPs: Quantidade de vezes que foi eleito MVP de uma partida.
* Podemos criar rankings separados (um ordenado por vitórias, outro por MVPs) ou um ranking combinado. A frase "baseado em vitórias e MVPs" sugere que ambas métricas são relevantes. Possibilidades:
o Ter dois rankings distintos: exibir a lista de jogadores ordenada por vitórias e, separadamente, por MVPs.
o Ou criar uma pontuação composta (ex: 1 ponto por vitória, 2 pontos por MVP, somar e ordenar). Contudo, isso pode ser arbitrário; é mais transparente mostrar os dois critérios separadamente.
* Implementação:
o Calcular o total de vitórias de cada jogador:
o Uma vitória de jogador conta quando ele jogou em uma partida e o time dele venceu essa partida. Em termos de dados: para cada registro em match_players do jogador, veja se matches.winner_team_id = players.team_id. Podemos computar via uma subquery SQL ou em lógica JS.
o Calcular total de MVPs de cada jogador:
o Basta contar quantas vezes o jogador aparece como matches.mvp_player_id.
o Ranking output: Podemos exibir em uma tabela todos os jogadores, com colunas "Vitórias" e "MVPs", e talvez permitir classificar por cada coluna. Ou então listar top 5 em cada categoria.
o Pagina Times: quando visualizando detalhes de um time, pode mostrar os jogadores daquele time com suas vitórias e MVPs.
o Página Home ou Jogadores (não listada explicitamente, mas poderíamos incluir na de Partidas ou Times): se quiser, destacar o jogador com mais MVPs e o com mais vitórias (às vezes é a mesma pessoa).
o Atualização de dados: sempre que inserir um match ou MVP, isso refletirá nessas contagens. Podemos recalcular ao exibir; dado o volume pequeno, é trivial. Para eficiência em futuro com mais dados, visões materializadas ou colunas calculadas poderiam ser usados, mas não necessário agora.
* Regras de Edição de Lineup (Jogadores em Partidas):
* Somente jogadores do próprio time podem ser escalados para suas partidas. Nosso sistema já garante isso pelo design (seleção de jogadores provavelmente filtrará pelo time).
* Um admin de time (admin_rac, admin_ast) poderia ter permissão para gerir apenas sua equipe:
o Ou seja, admin_rac pode adicionar/remover jogadores em RAC, mas não em AST, e vice-versa. Admin_super pode tudo.
o Isso precisaria ser respeitado tanto na UI (não mostrar botões indevidos) quanto possivelmente no back-end (RLS policies por exemplo, cheque profile.team_id).
* O lineup específico de uma partida: a princípio, qualquer jogador ativo no time pode ser escolhido. Não estamos rastreando titulares/reservas, então confiaremos no admin para escolher corretamente.
* Se por acaso quiser garantir número mínimo/máximo de jogadores numa partida, isso pode ser uma validação extra (ex: LoL deve ter exatamente 5 por time). Porém, o problema não exige esse nível de detalhe, podemos deixar livre.
* Implementação:
o Ao inserir jogadores participantes da partida (via match_players), filtre a lista de jogadores disponíveis por time. Por exemplo, ao preencher dados de uma partida no Admin:
o Mostrar multi-select dos jogadores RAC (lista todos players onde team = RAC) e multi-select dos jogadores AST.
o Ou dois componentes de seleção separados para cada lado.
o Salvando, cria múltiplas entries em match_players para cada jogador selecionado.
o Se necessário, pode adicionar um botão "Editar lineup" em partidas já registradas, caso precisem corrigir quem jogou. Isso permitiria deletar ou adicionar match_players registros vinculados àquela partida (e possivelmente recontar MVPs/vitórias se remover um jogador que ganhou? Mas se ele não jogou, não deveria ter ganho - só correção manual de dados).
o Edição de lineup também pode se referir a edição da lista de jogadores do time (roster). Por isso, clarifique:
o Gerenciar jogadores (roster): função de admin para adicionar/editar jogadores na tabela players.
o Editar lineup de partida específica: função para ajustar quem jogou em uma partida (pode ser desnecessário se evitarmos erros na inserção inicial, mas é bom ter opção).
Resumindo, as regras do campeonato ditam como os dados se relacionam (ex.: séries best of 3, pontos por série, etc.), e cabe ao código garantir integridade (não deixar inserir mais partidas do que possível, marcar vencedor corretamente, calcular placares). Conforme implementamos o front-end, podemos guiar o admin com validações e automatizações, por exemplo, atualizando o placar da série assim que marcam o vencedor de uma partida.
4. Páginas do Sistema e Funcionalidades
A aplicação terá várias páginas, cada uma com um papel específico. Abaixo descrevemos cada página esperada, seu conteúdo e comportamento. Lembre-se de usar os componentes de UI (shadcn/ui) e Tailwind para estilizar, mantendo uma aparência consistente (por exemplo, cores dos times, layout responsivo, etc.).
4.1 Página Home (Visão Geral)
* Descrição: Página inicial do site, acessível publicamente (sem login). Deve apresentar um resumo do campeonato e destaque das informações mais importantes.
* Conteúdo principal:
* Título/Header: Nome do campeonato ou uma breve apresentação (ex: "Campeonato RAC vs AST - Multigames").
* Placar Geral Atual: Mostrar claramente os pontos de cada time no campeonato até o momento. Por exemplo, um elemento visual "RAC 2 x 1 AST" se 3 séries já foram disputadas. Se o campeonato terminou, indicar o resultado final (e possivelmente destacar o campeão).
o Pode-se usar um componente de Badge ou Card com cores do time vencedor para indicar liderança.
* Resumo das Séries: Uma lista ou grid dos 5 jogos, com indicação do vencedor de cada um (se já aconteceu) ou data programada (se pendente):
o Exemplo: Mostrar ícone ou nome do jogo + "RAC venceu (2-0)" ou "AST venceu (2-1)", ou "Em breve" se não realizado. Cada item pode linkar para detalhes (página de Jogos ou série específica).
o Esse resumo permite ao visitante ver rapidamente quem ganhou em cada modalidade.
* Destaques de Jogadores: Opcional, mas interessante – por exemplo:
o Jogador com mais MVPs até agora, e jogador com mais vitórias (pode ser um "Leaderboard" simplificado). Exibir nomes e números.
o Talvez em formato de pequenas cards: "Top MVP: Jogador X (3 MVPs)" e "Jogador com mais vitórias: Jogador Y (10 vitórias)".
* CTA Login (se aplicável): Se o usuário não está logado e é um admin, pode haver um botão "Admin Login" discreto em algum lugar para entrar.
* Componentes e comportamento:
* Use um Card ou container central para o placar geral. Podem ser dois cards lado a lado (um de RAC e um de AST) mostrando o total de pontos de séries ganhos por cada um.
* A lista de séries (5 jogos) pode ser um Grid de cards ou uma Table com 5 linhas:
o Colunas: Jogo | Vencedor | Placar da Série.
o Se não jogado ainda, vencedor = "-" e placar = "–".
* Caso o campeonato esteja decidido (ex: 3 vitórias já para um lado), pode mostrar um destaque: "RAC CAMPEÃO!" com alguma estilização especial (um troféu emoji, etc.).
* Responsividade: em mobile, empilhar os elementos (placar geral em cima, lista de jogos abaixo).
* Nenhuma interação especial a não ser links de navegação. O conteúdo é estático derivado do banco (atualizado quando admin insere resultados).
4.2 Página Jogos (Series por Modalidade)
* Descrição: Página listando cada modalidade (jogo) e detalhes da série correspondente. O público pode ver aqui informações de cada um dos confrontos (jogo específico) entre RAC e AST.
* Conteúdo principal:
* Lista de Jogos/Modalidades: Apresentar os 5 jogos com informações do confronto de cada um:
o Nome do jogo (e possivelmente logo/ícone do jogo para visual).
o Placar da série (ex: "2-0" ou "2-1", ou vazio se ainda não ocorreu).
o Vencedor da série (se concluída) – por exemplo, um texto "Vencedor: RAC" destacado com cor do time vencedor.
o Status se ainda não realizado: por exemplo "Agendado para [data]" ou "Pendente".
* Link ou Ação: Cada item pode ser clicável para ver mais detalhes sobre aquela série (por exemplo, lista das partidas e MVPs). Isso pode abrir uma página dedicada (rota dinâmica /jogos/[id]) ou pode ser expandido na mesma página (mas mais simples é ter uma rota de detalhe).
o Suponha que implementemos uma página de detalhe para cada série, e.g. Página Detalhe da Série (Jogo).
* Possível Página de Detalhe de Série (ex: /jogos/[game]):
(Se implementado, ao clicar em um jogo na lista)
* Mostrar qual jogo e possivelmente informações gerais (talvez descrição do jogo, se quiser enriquecer).
* Listar as partidas daquela série:
o Exibir partida 1, 2, (3 se houve) com quem venceu cada uma e MVP.
o Ex: "Partida 1: vencedor RAC, MVP Jogador Z" etc.
* Mostrar de novo o placar agregado e vencedor da série.
* Essa página de detalhe serve também para admins adicionarem partidas? Poderia haver um condicional: se admin logado e série incompleta, mostrar formulário para adicionar próxima partida. (Isso pode facilitar UX do admin, mas também pode ser feito tudo no Admin central. Deixaremos principalmente no Admin centralizado, mas é uma ideia.)
* Componentes e comportamento na página Jogos:
* Usar uma Table ou Accordion:
o Poderia ser um Accordion onde o título é o jogo e dentro do painel expandido os detalhes da série. Mas com 5 itens, uma simples listagem talvez baste, e deixar detalhes para outra página ou modal.
* Cada jogo terá um pequeno indicativo visual do vencedor: por exemplo, usando um Badge com cor do time.
* Se optar por rota de detalhe: a página principal Jogos tem a lista e link, e a página [gameId] ou [seriesId] mostra os detalhes.
* Essa rota de detalhe deve ser pública também, e mostrar informações somente leitura das partidas e resultados.
* Consulta de dados: Fetch da lista de séries (join com games para nome, etc.) para a página principal. Para detalhe, fetch das partidas daquele series_id.
4.3 Página Partidas (Todas as Partidas)
* Descrição: Página que lista todas as partidas individuais registradas entre RAC e AST, em todas as modalidades, possivelmente para quem quer ver cada resultado granular e MVP. Útil para transparência e histórico.
* Conteúdo principal:
* Lista de Partidas: Pode ser apresentada em uma tabela com colunas, por exemplo:
o Jogo (modalidade)
o Partida (pode ser "LoL - Partida 1" ou "LoL #1", ou "Game 1" etc.)
o Vencedor da partida
o MVP da partida (se houve, ou indicar "—" se não houve)
o Talvez Data/Hora se registradas (caso partidas ocorram em momentos diferentes).
* Opções de filtro/ordenação: Se houver muitas partidas, poderíamos permitir filtrar por jogo (mostrar só partidas de LoL, etc.). Como são poucas (máx 5 séries * 3 partidas = 15 partidas totais neste campeonato), um único cronológico ou agrupado por jogo é ok.
o Poderia agrupar por jogo: por exemplo, sub-seções "LoL: [lista de partidas]", "R6: [lista de partidas]", etc., mas uma tabela ordenada por jogo ou data também funciona.
* Componentes e comportamento:
* Uma Table é ideal para listar partidas:
o Cabeçalho com colunas: Jogo | Partida | Vencedor | MVP.
o Cada linha: ex: Valorant | Partida 2 | AST | Jogador X.
* Destaque de cor para vencedor similar ao antes (ex: texto "AST" em azul, "RAC" em vermelho, conforme paleta definida).
* Se o número de partidas for limitado, paginação não é necessária. Caso contrário, poderíamos implementar paginação ou scroll.
* Essa página é somente leitura para usuários comuns. Para admins, não necessariamente permite edição aqui (edição de partida deve acontecer via Admin ou detalhe da série).
* Dados: Query todas as partidas, juntando dados relevantes (game name via series->game, winner team name via join, MVP name via join). Supabase permite usar select com múltiplos níveis ou RPC; ou pegar as tabelas separadas e combinar no front.
4.4 Página Times (Informações dos Times)
* Descrição: Página apresentando informações de cada time (RAC e AST). Como temos apenas dois times, pode ser uma página combinada mostrando ambos lado a lado, ou duas subpáginas (ex: /times/RAC e /times/AST). Aqui optamos por mostrar ambos, já que é um comparativo.
* Conteúdo principal:
* Resumo de Cada Time: Apresente para cada equipe:
o Nome completo (talvez RAC e AST sejam siglas; poderia exibir nome completo se existir, ex: "Equipe RAC" vs "Equipe AST").
o Pontuação geral no campeonato (quantos pontos/séries ganhou).
o Séries vencidas por modalidade: talvez listar quais jogos venceu. Ex: "Vitórias: LoL, CS" se ganhou aqueles.
o Se campeão geral, destacar isso.
* Lista de Jogadores do Time: Para cada time, listar seus jogadores:
o Nome do jogador.
o Estatísticas: número de vitórias e MVPs do jogador.
o Pode ordenar os jogadores do time pelo número de vitórias, por exemplo, para destacar quem mais contribuiu.
* Possibilidade de expans\u00e3o: fotos dos jogadores, etc., mas não exigido. Mantemos focado em dados textuais.
* Componentes e comportamento:
* Poderia ser uma página com Tabs ou colunas:
o Ex: duas colunas, esquerda RAC, direita AST. Ou uma seção em cima para RAC, abaixo AST (melhor em mobile).
o Dentro de cada seção, um Card com info do time e uma Table dos jogadores.
* No card do time: mostrar pontuação (por exemplo, "Pontos: 2", ou "Séries vencidas: 2 de 5"). Se quiser, mostrar vitórias em partidas também (soma de todas partidas que o time ganhou, embora isso não dê pontos extras, é apenas estatística).
* Tabela de jogadores do time:
o Colunas: Jogador | Vitórias em partidas | MVPs.
o Listar todos jogadores daquele time. Se a lista for grande, pode limitar ou scroll dentro do card.
* A página Times é pública. Dados exibidos vêm de teams, players e cálculos nas partidas:
o Para cada team, podemos fazer uma consulta agregada:
o Total de séries ganhas (contar series where winner_team_id = team.id).
o Total de partidas ganhas (contar matches where winner_team_id = team.id).
o Jogadores: lista players where team_id = X, e para cada já trazer contagem de vitórias e MVPs (talvez via subselects count).
o Ou pegar tudo separado e processar. Simplicidade: podemos calcular vitórias/MVPs por jogador previamente e depois dividir por time.
4.5 Página Admin (Painel Administrativo)
* Descrição: Página restrita a usuários autenticados (admins). Reúne funções para gerenciar o campeonato: cadastrar confrontos, registrar partidas, gerenciar jogadores (lineup) etc. Dependendo do nível do admin (super vs rac vs ast), algumas funcionalidades podem ser limitadas.
* Acesso:
* Somente acessível após login. Idealmente,:
o admin_super: vê e pode usar todas as funções.
o admin_rac: pode gerenciar somente coisas do time RAC (ex: adicionar jogadores no RAC, talvez inserir resultados? Ou deixar resultados para super? Depende da confiança, mas poderia permitir inserir partidas que envolvem rac, ou seja todas já que o adversário é fixo).
o admin_ast: similar para AST.
o Detalhe: Poderíamos restringir que admin_rac e admin_ast não marquem o vencedor da série de forma injusta. Porém, já que ambos podem acessar, quem insere primeiro registraria. Talvez melhor que apenas admin_super registre resultados oficiais, enquanto admin_rac/ast só gerenciam seus rosters. Mas o enunciado não diz isso explicitamente. Para fins de resposta, consideraremos que admin_rac e admin_ast podem registrar partidas, assumindo cooperação (ou poder de registrar suas vitórias, mas não altera nada sem o adversário confirmar, fica confuso).
o Simplicidade: tratar todos admins iguais em capacidade de registro de resultados, ou deixar admin_super para registros e os de team só para lineup. Indicaremos possibilidades.
* Conteúdo principal (Admin): Pode ser estruturado em subseções ou abas para cada tipo de operação:
* Gerenciar Confrontos (Séries):
o Lista das séries (os 5 jogos). Mostrar estado (não iniciado, em andamento, concluído).
o Capacidade de cadastrar uma nova série se fosse necessário (no caso deste campeonato específico, as séries já estão definidas pelos 5 jogos; podemos pré-criá-las no BD ou permitir criar. Se permitir criar, você seleciona o jogo e cria a série).
No contexto atual, você teria no máximo 5 séries. Talvez não precise interface de adicionar, mas pelo menos de visualizar e editar.
o Editar série: Poder alterar data/hora ou marcar manualmente um vencedor se por algum motivo não forem jogar partidas (ex: W.O.). Porém, normalmente o vencedor é determinado pelas partidas. Talvez apenas admin_super poderia forçar um resultado.
o Ação de reset/excluir série, caso cadastrada errado (cuidado, excluir deveria apagar as partidas filhas também).
* Gerenciar Partidas:
o Para cada série (pode estar aninhado sob cada série na interface), listar as partidas já registradas e um formulário para adicionar nova partida enquanto a série não estiver completa.
o Formulário adicionar partida inclui:
o Seleção do vencedor (RAC ou AST).
o Seleção dos jogadores participantes de cada time (listas de checkboxes ou multiselect para RAC e AST).
o Seleção de MVP (dropdown de todos jogadores que participaram da partida, ou possibilidade de "nenhum").
o Botão submit para salvar.
o Ao adicionar, atualizar a lista de partidas da série e o placar da série automaticamente.
o Se a série atingir 2 vitórias para algum lado, pode bloquear adição de mais partidas (o formulário pode sumir ou desabilitar).
o Também permitir editar ou remover uma partida cadastrada (ex: se inserido vencedor errado ou MVP errado). Edições devem ajustar contagens (no banco, se editar vencedor talvez precisar atualizar placar da série).
* Gerenciar Jogadores (Lineup/Roster):
o Lista de jogadores de cada time (pode ser tabulado por time ou dois blocos).
o Para admin_rac e admin_ast, mostrar apenas seus próprios times. Para admin_super, mostrar ambos.
o Função Adicionar Jogador: formulário pedindo nome e seleção do time (no caso de admin_super) ou fixo se admin de time (ex: admin_rac não escolheria time, pois já se presume RAC).
o Listagem: mostrar nome do jogador e talvez estatísticas básicas.
o Ações: Editar (renomear, trocar time se erro – embora trocar time de jogador histórico bagunça estatística, evitar a menos que necessário) e Remover jogador (cuidado: remoção de jogador que já participou de partidas deixaria referências órfãs em match_players/MVP; melhor desabilitar remoção nesses casos ou exigir limpeza dos dados).
o Possível melhoria: Em vez de remoção física, poderia ter um campo "ativo/inativo" para não perder histórico. Mas não precisa complicar; pode simplesmente bloquear exclusão se participou de partida.
* Outras ações administrativas:
o Autenticação: talvez fornecer opção de trocar senha para admin (mas Supabase Auth não facilita isso via simples UI nossa, seria via supabase diretamente ou a lib).
o Não é obrigatório implementar na interface. O admin_super poderia querer criar novos admins? Não necessário aqui (fixos).
o Encerrar Campeonato: um botão que marca campeonato como finalizado – não realmente necessário, pois quando 5 séries cadastradas (ou 3 ganhos por alguém) já está encerrado implicitamente.
* Componentes e comportamento (Admin):
* Podemos dividir a página Admin em abas ou seções usando Tabs componente:
o Abas: "Séries", "Partidas", "Jogadores", etc. Ou "Confrontos & Partidas" em uma aba e "Jogadores" em outra.
o Alternativamente, ter tudo numa página contínua com headings.
* Dentro de cada aba/seção:
o Usar Table para listagens (ex: lista de jogadores, lista de partidas).
o Usar Form components (Labels, Inputs, Selects, Buttons) do shadcn/ui para os formulários.
o Exemplo: Ao lado de "Jogadores do Time RAC", um botão "+ Jogador". Ao clicar, abre um Dialog modal ou expande um form inline para inserir dados do jogador.
o Nos itens listados, ícones de editar/deletar (pequenos Button com ícone de pencil/trash, possivelmente usando shadcn's AlertDialog para confirmar deleção).
o Para adicionar partida: se cada série na listagem de séries tiver uma seção expandida para partidas, então sob a lista de partidas daquela série, inclua o formulário de nova partida quando aplicável.
* Validações:
o Nos formulários de partidas, garantir que MVP só possa ser escolhido se foi marcado como participante daquela partida.
o Nos formulários de jogador, evitar duplicados de nome no mesmo time (se quiser, não obrigatório).
o Ao registrar partida, se a partida é a segunda vitória de um time, atualizar a série como concluída:
o No UI: pode mostrar que série concluída e não oferecer mais partidas.
o No BD: setar series.winner_team_id e marcar is_completed.
o Se admin tentar adulterar (ex: admin_rac tentando editar AST players via API), rely on RLS to block if set, ou simplesmente confiar no front.
* Experiência:
o Mostrar mensagens de sucesso/erro após operações (ex: "Partida adicionada com sucesso", ou erros vindo do supabase).
o Carregar dados atuais ao entrar na página Admin, e permitir refresh (ou usar reatividade se usando libs como SWR ou context).
4.6 Página Login
* Descrição: Página para que os admins possam entrar no sistema. Pública no sentido de acesso (todos podem ver), mas as credenciais válidas são apenas as três de admin.
* Conteúdo principal:
* Formulário de Login: Campos para email e senha. Possivelmente logo do campeonato ou nome do sistema.
* Botão "Entrar": submete as credenciais para autenticação via Supabase.
* Mensagem de erro se falhar (credenciais incorretas).
* Talvez link "Esqueci a senha" caso fosse possível (Supabase poderia enviar email de reset, mas com 3 usuários fixos pode não ser necessário; admin_super poderia resetar via DB se preciso).
* Componentes e comportamento:
* Pode utilizar componentes de formulário do shadcn/ui para estilizar (Input, Button).
* Ao autenticar:
o Use o supabase client no front (supabase.auth.signInWithPassword).
o Em caso de sucesso, o Supabase Auth irá armazenar um cookie (se usando a configuração SSR) ou retornar sessão. Redirecione o usuário para a página Admin ou Home.
o Em caso de falha, mostre um alerta ou mensagem (pode usar um componente Toast do shadcn para notificar, ou simplesmente texto vermelho abaixo do form).
* Se o usuário já estiver logado e tenta acessar /login, redirecionar para /admin ou Home (não faz sentido relogar).
* Segurança: Assegure uso de HTTPS em produção (Vercel já provê), supabase vai exigir se configurado adequadamente. As credenciais via supabase-js vão seguras. Não deixe a Service Role Key exposta no front (apenas use Anon).
5. Rotas Públicas vs Protegidas
É importante definir claramente quais rotas (páginas API ou páginas Next) podem ser acessadas por qualquer visitante e quais exigem autenticação de admin:
* Rotas Públicas (acesso livre, só leitura):
* / (Home): Visão geral do campeonato, placar, destaques.
* /jogos: Lista de jogos/modalidades e resultados de cada série.
* /jogos/[id] (se houver detalhe de série): detalhes de partidas daquela modalidade.
* /partidas: Lista de todas as partidas e MVPs.
* /times: Informações sobre os times e jogadores.
* /login: Página de login dos admins. (Deve ser acessível para permitir login, porém podemos ocultá-la das navegações públicas).
* /api/* (se implementar APIs públicas de leitura, ex.: /api/rankings, mas não obrigatório; Next app router pode buscar direto do DB server-side).
* Rotas Protegidas (exigem login):
* /admin: Painel admin principal, incluindo sub-funções de gerenciar séries, partidas, jogadores.
o Podemos também segregar em sub-rotas, por exemplo: /admin/jogos, /admin/partidas, /admin/jogadores. Mas se tudo estiver na página /admin com condicional de tabs, essas sub-routes não são necessárias.
* /api/* (se implementar rotas API para criar/editar dados, devem exigir auth):
o Por exemplo, um endpoint /api/admin/addMatch etc. Entretanto, podemos evitar rotas API extras e usar diretamente Supabase desde o client or server components, já que supabase-js vai direto ao DB com auth do user. Ainda assim, se criar API route, use verificação de supabase auth (via supabase auth-helpers or checking JWT in headers).
* Implementando Proteção:
* Com o App Router, criar um middleware.ts no projeto Next:
o Ele pode verificar se a request é para rota admin (req.nextUrl.pathname.startsWith('/admin')) ou para API sensível.
o Se for e não houver token de supabase no cookie (ou no caso de RLS, supabase define req.supabaseAuthToken talvez), redireciona para /login.
o A supabase auth-helpers library oferece integração com Next middleware para validar JWT facilmente, podemos usar se quiser. Caso contrário, uma estratégia simples: no login, também setar um cookie custom ou NextAuth (mas preferimos manter supabase's).
* Alternativamente, dentro do componente da página admin, usar um pattern:
o Utilizar cookies() do next (server component) para obter supabase session user (existe integração do supabase-helpers to get user server-side). Ou
o Fazer const { data: { user } } = await supabase.auth.getUser() no componente server-side. Se user null, redirect.
* Simples: Use supabase-js in client: if no user, on useEffect => router.push('/login'). But this might flicker. Better use the server approach.
* Autorização granular: Dentro do admin, para ações específicas:
o Checar role do usuário logado. Ex: se user role = 'rac', esconder ou desabilitar controles referentes ao AST. Ex: na seção de gerenciar jogadores, admin_rac não vê lista do AST.
o Se for metadados, ao autenticar podemos guardar também role no context.
o Em qualquer chamada sensível (like supabase insert), pode adicionalmente verificar no DB se permitido (RLS can enforce e.g. only allow insert into players if profile.team_id = players.team_id).
* Rotas de API protegidas: (Opcional, somente se usar API routes)
* Next API routes (in /pages/api or the new app/api route handlers) can guard by checking the supabase JWT:
o For example, in an API route to add match, parse Authorization header or cookie, verify token with supabase (Supabase provides a method or we can decode since it's JWT). Or simpler: call supabase auth client in that route context with service key to identify user by sending the JWT for verification.
o If user not admin or not logged, return 401.
* However, an easier architecture: directly call supabase from client in admin (since supabase-js will use logged-in user's access token and RLS to allow/refuse). That way no separate API code needed for basic CRUD.
Em resumo, todas as páginas de visualização são abertas a todos, e todas as ações de escrita/gerenciamento são restritas ao Admin (painel). Qualquer tentativa de acessar /admin sem login redireciona para /login. Após login, se um admin de time tentar algo indevido (como editar o outro time), caberá ao front esconder as opções e ao back (RLS ou validação) prevenir a operação.
6. Ações do Admin (Permissões e Funcionalidades Detalhadas)
Nesta seção resumimos tudo o que um administrador pode fazer no sistema e quais restrições existem, organizando por tipo de admin quando aplicável:
* Cadastrar Confronto (Criar Série):
* Quem: admin_super (idealmente). admin_rac/ast talvez possam sugerir confrontos, mas nesse caso específico os confrontos são fixos. Vamos supor apenas admin_super ou ambos de time caso o calendário não esteja pré-definido.
* O quê: Criar um registro na tabela series para um determinado jogo, caso ainda não exista. Isso envolve selecionar a modalidade (game) e possivelmente data/hora.
* Como (UI): Na página Admin > seção Séries, botão "Novo Confronto" (ou ao lado de cada jogo se não criado ainda). Abre form: seleção do jogo (dropdown dos jogos ainda não utilizados em alguma série ativa, para evitar duplicar), campo data (opcional).
* Validações: Não duplicar série do mesmo jogo (a menos que fosse outro campeonato/rodada, mas não é o caso). Se já existe série para LoL, não criar outra a menos que for reiniciar campeonato.
* Ação no BD: insert em series com game_id e data. No início, winner_team_id fica null, scores 0.
* Conseq\u00fc\u00eancia: Após criar, a série aparecerá na lista de Jogos (pública) como pendente. Admins podem então registrar partidas para ela.
* Registrar Partidas (Adicionar Partida a uma Série):
* Quem: admin_super, admin_rac, admin_ast (desde que logados). Dependendo das políticas definidas:
o Se confiarmos, qualquer admin pode inserir.
o Para controle, poderíamos restringir que apenas admin_super insira as partidas oficiais, mas isso não foi explicitado. Provavelmente permitem os admins de time inserirem resultado quando terminarem a partida.
* O quê: Adicionar um registro em matches vinculado a uma série existente. Escolher quem ganhou e outros detalhes.
* Como (UI): Na seção Partidas dentro de Admin (talvez aninhada por série):
o Selecionar qual série (se interface separada, ou se você clica numa série e dentro dela tem "Adicionar partida").
o Campo vencedor (radio ou select entre RAC/AST).
o Campos jogadores: multi-select ou duplo select para jogadores do time RAC e do AST que participaram.
o Campo MVP: select de um jogador dentre os participantes listados (ou opção "Nenhum").
o Submit -> valida -> salva.
* Valida\u00e7\u00f5es de regra:
o Não permitir adicionar mais que 3 partidas numa série.
o Se já existe um vencedor da série (2 vitórias atingidas), bloquear novas partidas.
o Se MVP selecionado mas não estava na lista de participantes, erro.
o Opcional: Se esquecido MVP não é problema (pode deixar MVP vazio).
* A\u00e7\u00e3o no BD: insert em matches + múltiplos insert em match_players para vincular os jogadores.
o Pode ser em uma transa\u00e7\u00e3o (para garantir consistência). Supabase pode ter que chamar um RPC para transacional, pois várias queries.
o Ou inserimos a partida primeiro para obter ID, depois inserimos participantes (no client side sequencial).
o Atualizar series.score_rac ou series.score_ast: isto pode ser feito:
o Via trigger no DB (ao inserir match, incrementar contagem).
o Ou no front: após sucesso do insert, chamar um update series set score_rac/ast, ou calcular antes e enviar.
o Simples: front pode contar quantas partidas do series tal o RAC ganhou (1 a mais que antes) e mandar update.
o Se o insert fez a série completar (um dos scores chegou a 2):
o Marcar series.winner_team_id com o time que atingiu 2 vitórias, is_completed=true.
o Isso também no front via update ou via trigger no DB (trigger poderia verificar count(*)).
o Nota: Uma abordagem robusta seria ter uma função armazenada no Supabase: select register_match(series_id, winner_team_id, mvp, players_rac, players_ast) que internamente faz todos inserts e updates de placar. Mas pode-se implementar no código sem stored proc.
* Conseq\u00fc\u00eancia: O placar da série é atualizado. Se a série concluiu, o placar geral do campeonato pode mudar (um time ganha 1 ponto). Isso refletirá nas páginas públicas.
* Editar/Remover Partida:
* Quem: Provavelmente apenas admin_super. Se admin_rac inseriu errado, talvez só super pode corrigir? Depende.
o Podemos permitir que o próprio admin de time edite se logo em seguida notou erro. Mas para segurança de dados oficiais, vamos assumir admin_super pode.
* O quê: Alterar os dados de uma partida já registrada (corrigir vencedor, mvp) ou deletar uma partida (por exemplo, se foi anulada).
* Como (UI): Na lista de partidas da série, ao lado de cada partida, ícones de Editar (pencil) e Excluir (trash).
o Editar: abre form populado permitindo mudar vencedor (e MVP, etc.). Ao salvar, tem que recalcular implicações:
o Se mudar vencedor, altera total de vitórias no série: requer recalcular series.score_rac/ast. (Mais simples: recompute do zero contando as partidas atualizadas).
o Se por causa da edição a série agora teria outro vencedor (ex: antes AST tinha 2-1, se vc trocou uma vitória pro RAC, pode empatar 2-1 pro outro lado), talvez mudar series.winner_team_id.
o Isso é complexo; possivelmente bloquear editar vencedor se isso muda o outcome já fechado? Mas permitir se foi erro grave.
o Remover: confirmar exclusão. Ao remover:
o Remove match e seus match_players.
o Recalcula placar da série (ex: volta de 2-1 para 1-1 se removeu uma vitória).
o Se remover a partida que decidia a série, limpar winner_team_id e marcar série não completa se necessário.
* Valida\u00e7\u00f5es:
o Não permitir excluir partida se não for necessário, especialmente se já é histórico oficial. Mas como admin_super, ok.
o Se a série estava completa e está reabrindo, tudo bem, mas deve refletir.
* Ação no BD:
o update matches para editar ou delete from matches (cascata ou manual para match_players).
o Recalcular/atualizar série conforme descrito.
o Podemos também simplesmente recomputar do banco: contagem de matches vencedor=RAC vs AST para aquela série e atualizar scores e winner de acordo.
* Conseq\u00fcncia: Dados corrigidos; rankings e placares se ajustarão.
* Cadastrar Jogador:
* Quem: admin_super (para qualquer time), admin_rac (apenas adiciona em RAC), admin_ast (apenas AST).
* O quê: Adicionar um novo jogador na tabela players.
* Como (UI): Na seção Jogadores do Admin, botão "+ Jogador". Form: Nome do jogador, selecionar Time (se admin_super) ou fixo se admin de time (já sabe o time).
* Valida\u00e7\u00f5es: Nome não vazio. Poderia checar duplicidade de nome no mesmo time para evitar confusão.
* Ação no BD: insert em players (id auto-gen, name, team_id).
* Conseq\u00fc\u00eancia: O jogador passa a aparecer na lista do time e disponível para selecionar em partidas.
* Editar Jogador:
* Quem: admin_super (qualquer jogador), admin_rac (somente jogadores do seu time), admin_ast (somente do seu time).
* O quê: Alterar nome do jogador (ou eventualmente transferir de time, mas isso não faz sentido mid-campeonato; evitar fazer isso pois muda histórico).
* Como (UI): Ícone de editar ao lado do nome do jogador na lista. Abre modal para editar campos.
* Valida\u00e7\u00f5es: Similar ao cadastro: nome não vazio, etc. Se mudar de time, talvez não permitir se já teve partidas (ou proibir completamente trocas).
* Ação no BD: update players set name = ... (e/ou team_id se for implementado transferência).
* Conseq\u00fc\u00eancia: Nome atualizado reflete em todas listas e partidas (MVP list etc.). Transferência, se feita, significaria precisamos atualizar match_players históricos para manter coerência? Por isso, melhor não implementar transferência nesta versão.
* Remover Jogador:
* Quem: admin_super (qualquer jogador), possivelmente admin_rac/ast (se nenhum dado vinculado).
* O quê: Apagar jogador da tabela players.
* Como (UI): Ícone de lixeira ao lado do jogador. Confirmar exclusão.
* Valida\u00e7\u00f5es: Se o jogador já participou de alguma partida (tem registros em match_players ou como MVP), idealmente bloquear remoção ou avisar que não pode remover pois afetaria histórico. Poderíamos decidir não permitir deletar nesses casos (em vez disso, em versões futuras marcar como "inativo"). Para agora: validação manual, se tentativa, ou RLS prevenindo se existirem refs.
* Ação no BD: delete from players where id = .... Se não há constraints ON DELETE, match_players/MVP ficarão órfãos. Para prevenir, ou definimos constraint cascade (players.id referenced, ON DELETE RESTRICT para bloquear se houver referência). Melhor usar RESTRICT.
* Conseq\u00fc\u00eancia: Jogador removido não aparece mais. (Se algum admin precisasse, admin_super poderia limpar partidas associadas para remover alguém, mas não vale a pena complicar.)
* Outras Ações de Admin Super:
* Gerenciar Admins (não requisitado, 3 fixos).
* Limpar dados ou reiniciar campeonato (talvez apagar todas partidas e séries para começar de novo, mas cuidado com cascatas).
* Exportar dados (não requisitado, mas admin poderia extrair planilha, etc., não iremos implementar).
Em resumo, admin_super tem controle total de criar confrontos, inserir resultados e gerenciar dados de ambos times. admin_rac e admin_ast têm poderes mais limitados: provavelmente gerenciam seus respectivos rosters e possivelmente inserem resultados das partidas (se permitido). Essas regras de permissão devem ser refletidas tanto na interface (exibir ou não botões/opções) quanto no nível de segurança (RLS ou verificações no backend).
7. Regras de Negócio: Cálculo de Rankings
Aqui detalhamos como calcular os rankings e estatísticas a partir dos dados, para garantir que o código reflita corretamente as regras:
* Cálculo do Ranking Geral de Times:
* Definição: Contagem de séries vencidas por cada time.
* Como obter: Consultar a tabela series:
o Contar quantos registros têm winner_team_id = RAC e quantos têm winner_team_id = AST.
o Isso resulta nos pontos de RAC e AST no campeonato (cada série vencida = 1 ponto).
o Exemplo de query (SQL conceitual):

  SELECT 
  (SELECT count(*) FROM series WHERE winner_team_id = <RAC_id>) as rac_wins,
  (SELECT count(*) FROM series WHERE winner_team_id = <AST_id>) as ast_wins;
o Ou contar total de series e derivar o outro por diferença se só 2 times. Mas contando separado é claro.
* No código Next.js: Pode chamar essa query via Supabase (RPC ou query builder) ou simplesmente trazer todas as séries e contar em JS.
* Atualização: Sempre que uma série ganha um winner, esses counts mudam. Podemos recalc a cada render ou usar revalidation (se SSR) ou on-demand revalidate no Next if using ISR.
* Ranking por Jogo (Modalidade):
* Definição: Qual time foi o melhor em cada jogo. Dado que só tem RAC vs AST e um confronto por jogo, é basicamente o vencedor daquela série.
* Como obter: Olhar cada entrada em series unindo com games:
o Para cada game, ver series.winner_team_id.
o Podem ser exibidos simplesmente como "Jogo X: Vencedor Y".
o Se quisermos formalizar: é como um mini-ranking de 2 dentro daquela modalidade (1º lugar e 2º lugar). Mas sendo só dois, apenas mostrará quem ganhou.
o Em caso futuro com mais times ou várias partidas por jogo, você poderia calcular percentuais ou quantas vitórias em LoL cada time tem, etc. Não é o caso aqui, então mantemos simples.
* No código: Já ao listar séries por jogo (como planejado na página Jogos), obtemos series + game e já sabemos o vencedor. Nenhum cálculo complexo, apenas exibição do resultado.
* Cálculo de Ranking de Jogadores (Vitórias e MVPs):
* Precisamos contabilizar:
o Vitórias por jogador: total de partidas vencidas nas quais o jogador participou. (Nota: Se contássemos séries vencidas pelo jogador, seria diferente pois um jogador poderia não jogar todas partidas; por isso vamos por partidas.)
o MVPs por jogador: total de partidas em que foi marcado MVP.
* Como obter vitórias por jogador:
o Temos match_players que relaciona jogador e partida, e matches que diz qual time venceu. Também sabemos o time do jogador via players.team_id.
o Então, uma vitória para o jogador ocorre se: existe um registro em match_players com player_id = X e para o mesmo match_id, matches.winner_team_id = players.team_id (do jogador).
o Em SQL poderia ser:
  SELECT player_id, COUNT(*) as wins
FROM match_players mp
JOIN matches m ON mp.match_id = m.id
JOIN players p ON mp.player_id = p.id
WHERE m.winner_team_id = p.team_id
GROUP BY player_id;
  (Esse count seria as vitórias por jogador.)
o Observação: Se um jogador não jogou numa partida que seu time venceu, ele não recebe crédito daquela vitória, pois não participou. Isso parece lógico, já que estamos valorizando vitórias jogadas pelo jogador.
o Alternativamente, poderíamos contar vitórias de todas partidas do time para todos jogadores do time (mesmo os que não jogaram)? Não, isso não faz sentido, normalmente vitória é contada para quem jogou.
o Portanto, seguimos: vitória contabilizada somente se jogador esteve em jogo e ganhou.
* Como obter MVPs por jogador:
o Simples: contar quantas vezes matches.mvp_player_id = player.id.
o SQL:
  SELECT mvp_player_id as player_id, COUNT(*) as MVPs
FROM matches
WHERE mvp_player_id IS NOT NULL
GROUP BY mvp_player_id;
o Se MVP pode ser nulo ou não sempre escolhido, excluímos nulos.
* Combinar resultados:
o Podemos fazer duas sub-consultas e juntar, ou pegar via código:
o Por exemplo, via supabase-js:
* Chamar from('match_players').select('player_id, matches(winner_team_id), players(team_id)') e filtrar e contar no JS.
* E from('matches').select('mvp_player_id') e contar freq no JS.
o Ou criar views no DB: Uma view player_stats com colunas player_id, wins, mvps. Isso facilitaria um único select para o front.
o Para exibir o ranking de jogadores:
o Podemos criar um array de objetos { player, wins, mvps } e depois ordenar por wins ou mvps conforme precisamos para diferentes rankings ou just display in table with both columns.
o Provavelmente, exibir uma tabela de todos jogadores com suas vitórias e MVPs é suficiente. O "ranking" poderia ser sorted by wins desc, MVP desc, or just let user visually parse.
o Para destacar, você poderia ressaltar quem tem maior número em cada coluna.
* No front-end:
o Página Times: já dissemos, lista jogadores do time com stats. Pode ordenar internamente por vitórias.
o Poderíamos adicionar uma seção extra (talvez na Home ou Partidas) com "Top 5 Jogadores - Vitórias" e "Top 5 - MVPs". Com apenas 2 times e um evento, o número de jogadores não é grande, então não crucial, mas é legal. P.ex., Top MVP muito provavelmente um do time vencedor.
o De qualquer forma, implementar obtendo os counts e ordenando não é complexo.
o Nota: se dois jogadores empatam em vitórias ou MVPs, o ranking tem empate, e tudo bem.
* Atualização dinâmica vs armazenamento:
* Vamos calcular sempre que necessário em tempo real, dado o escopo pequeno. Não armazenaremos contadores de vitórias/MVP no player row, para evitar inconsisência.
* Somente se performance fosse problema, poderíamos atualizar um campo players.wins e players.mvps via triggers toda vez que se insere um match, mas não vale complicar agora.
* Verificação de consistência:
* Deve-se garantir que o sistema não credite vitória para jogador do lado perdedor (nossa condição SQL cuida disso).
* MVP pode, teoricamente, ser de qualquer lado (geralmente é do time vencedor, mas às vezes pode-se dar MVP pro melhor do perdedor? Depende da convenção. Se for MVP sempre de time vencedor, talvez poderíamos validar isso também).
* Se quiser garantir MVP é do time vencedor:
o Adicionar validação: if matches.winner_team_id != players.team_id (do MVP) então talvez exibir aviso mas salvar mesmo assim se admin insistir? Fica a critério. Para simplicidade, não forçaremos, mas possivelmente MVP tende a ser do vencedor.
Resumindo, os rankings e estatísticas serão todos derivados das tabelas de partidas e séries. Implementando as queries corretas ou processamento de arrays, exibiremos as informações conforme requisitado.
8. Estrutura de Arquivos do Projeto
Organizar bem os arquivos e pastas do projeto Next.js garante manuten\u00e7\u00e3o facilitada e um desenvolvimento mais limpo. Segue uma sugestão de estruturação para este projeto:
/campeonato-rac-ast
??? app/
?   ??? layout.tsx          # Layout root do Next.js (pode incluir navbar, provider do supabase, tema, etc.)
?   ??? globals.css         # CSS global (Tailwind import, etc.)
?   ??? page.tsx            # Página Home
?   ??? login/
?   ?   ??? page.tsx        # Página Login
?   ??? jogos/
?   ?   ??? page.tsx        # Página lista de Jogos (séries por modalidade)
?   ?   ??? [id]/page.tsx   # (Opcional) Página detalhe de série de jogo específico
?   ??? partidas/
?   ?   ??? page.tsx        # Página lista de Partidas
?   ??? times/
?   ?   ??? page.tsx        # Página Times (info dos times e jogadores)
?   ??? admin/
?   ?   ??? page.tsx        # Página Painel Admin (pode incluir tabs para séries, partidas, jogadores)
?   ?   ??? series/         # (Opcional) sub-pastas se quisermos separar páginas/UX, ex:
?   ?   ?   ??? [id]/page.tsx   # (Opcional) Admin - detalhe/editar série específica
?   ?   ??? jogadores/      # (Opcional) Admin - gerenciar jogadores
?   ?   ??? ... (outros if needed)
?   ??? api/                # Rotas API Next.js (se usadas)
?       ??? auth/route.ts   # ex: custom route login (não necessário se usamos supabase-js diretamente)
?       ??? ... (outros endpoints)
??? components/             # Componentes React compartilhados
?   ??? ui/                 # Componentes importados do shadcn/ui (por exemplo, button.tsx, input.tsx, etc.)
?   ??? layout/             # Componentes de layout (Navbar, Footer, perhaps AdminMenu, etc.)
?   ??? table/              # Componentes específicos, ex: TableRankings.tsx etc.
?   ??? form/               # Form field components or form layouts.
?   ??? ... (outros agrupamentos conforme necessidade)
??? lib/
?   ??? supabaseClient.ts   # Configuração do cliente Supabase para uso no client (ou ambos)
?   ??? supabaseServer.ts   # (Opcional) Supabase helper para uso em server components (usu\u00e1rio via cookies)
?   ??? auth.ts             # (Opcional) funções auxiliares de autenticação (ex: getUser server-side)
?   ??? ... (outros utilitários, ex: funções de cálculo de ranking)
??? hooks/
?   ??? useAuth.ts          # (Opcional) Hook customizado para fornecer user e login/logout actions facilmente no client
?   ??? useFetchData.ts     # (Opcional) Hook para buscar dados com cache (poderia usar SWR ou React Query)
??? styles/
?   ??? (qualquer config extra de estilo, se n\u00e3o usar apenas tailwind)
??? public/
?   ??? images/             # Logos, iconografia (ex: logos dos times, ícones dos jogos se usar)
??? middleware.ts           # Middleware para prote\u00e7\u00e3o de rotas (redirecionamento se n\u00e3o logado)
??? tailwind.config.js      # Config Tailwind (incluindo temas se customizar, cores dos times)
??? shadcn.config.json      # Configura\u00e7\u00e3o do shadcn UI (componentes registrados)
??? next.config.js          # Configura\u00e7\u00f5es do Next.js (se precisar ajustar algo)
??? package.json
Notas sobre a estrutura:
* Estamos usando o App Router do Next 13+, por isso as páginas ficam em app/ e não em pages/. Isso permite usar componentes React server-side e segmentar rotas facilmente.
* A presença de subdiretórios como admin/series/[id] é opcional; podemos manter tudo em admin/page.tsx dependendo de como complexa fica a UI. Se ficar muito grande, separar sub-páginas para certas funções pode ajudar a manter cada componente focado. Por exemplo, poderíamos ter:
* /admin/jogadores para gerenciamento de jogadores,
* /admin/series para confrontos,
* e assim por diante, com navegação interna.
Mas dado o escopo controlado, um painel único com tabs pode bastar.
* components/ui: essa pasta contém os componentes importados via shadcn (como botão, input, dialog, etc.), que geralmente vêm pré-estilizados. Não editar esses arquivos manualmente exceto se for customizar design.
* components/layout: possivelmente terá Navbar.tsx (incluindo links de navegação: Home, Jogos, Partidas, Times, e Admin/Login conforme estado) e talvez um Footer. O app/layout.tsx pode usar <Navbar /> no topo e definirmos um <Provider> para Supabase or context if needed.
* Poderemos ter também components/admin para componentes específicos do painel admin (por ex: a tabela de séries com botões, um form de partida, etc.), para deixar admin/page.tsx mais limpo.
* lib/supabaseServer.ts: se usando SSR com supabase, o supabase-helpers oferece funções para obter o usuário servidor. Podemos configurar para extrair o usuário via cookies (ex: createRouteHandlerClient em middleware). Se não for usar SSR para user (poder apenas usar client state), podemos ignorar.
* hooks/useAuth.ts: se decidirmos gerenciar o estado de autenticação manualmente no client (subscribe ao supabase onAuthStateChange, etc.), podemos encapsular isso aqui. O template with-supabase pode já prover contexto de Session.
* styles/: Tailwind permite custom theme. Podemos definir no tailwind.config.js cores custom, e.g., team colors: rac: '#FF0000', ast: '#0000FF' (se quisermos usar classes como bg-team-rac). Adicionar essas no theme extends.
* middleware.ts: Exemplo de implementação:
  import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
export function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  // Bypass if public route or static assets
  if (pathname.startsWith('/_next') || pathname.startsWith('/api/public') || pathname === '/login' || pathname === '/') {
    return NextResponse.next();
  }
  // Protect /admin routes
  if (pathname.startsWith('/admin')) {
    const token = request.cookies.get('supabase-auth-token'); // pseudo-code; actual cookie name might differ
    if (!token) {
      const url = request.nextUrl.clone();
      url.pathname = '/login';
      return NextResponse.redirect(url);
    }
    // Optionally, verify token or decode role if we want to restrict by role as well.
  }
  return NextResponse.next();
}
  (Ajustar para o real cookie: supabase usa sb-access-token e sb-refresh-token cookies se cookie auth mode).
* We will ensure .gitignore covers .env etc.
Essa estrutura é apenas uma sugestão; adapte conforme as preferências do time. O importante é separar responsabilidades: páginas (roteamento), componentes reutilizáveis, lógica de dados (lib/hooks) e configuração.
9. Observações Futuras para Versão 2.0
Algumas ideias e considerações para evoluir o projeto em versões futuras, aprimorando funcionalidades ou expandindo o escopo além do pedido inicial:
* Generalizar para Múltiplos Campeonatos ou Mais Times: Atualmente o sistema presume um campeonato fixo entre RAC e AST. Uma versão 2.0 poderia permitir configurar torneios com vários times e múltiplos confrontos:
* Poder ter uma tabela tournaments e relacionar series a um torneio, e times participantes. Assim, poderia-se reutilizar o sistema para outros eventos.
* Suportar campeonatos com mais de duas equipes, possivelmente em formato liga (todos contra todos) ou mata-mata. Isso exigiria mudanças grandes nas regras e UI (tabelas de classificação, etc.).
* Mesmo mantendo foco em RAC vs AST, talvez realizar esse evento anualmente – então ter edições diferentes (2025, 2026) que fiquem armazenadas.
* Gerenciamento de Usuários e Auth mais robusto:
* Adicionar possibilidade de um admin criar outros usuários (por exemplo, adicionar um novo admin de time se os grupos mudarem de nome, etc.).
* Implementar fluxo de reset de senha via email com Supabase (para os admins).
* Incluir autenticação de dois fatores para admin_super (melhorar segurança, especialmente se for exposto publicamente).
* Melhorias de UI/UX:
* Adicionar imagens e identidade visual:
o Logos ou avatares para os times RAC e AST, exibidos ao lado dos nomes.
o Ícones para cada jogo (podemos mostrar um pequeno logo do jogo nas listas para fácil reconhecimento).
* Incluir gráficos ou visualizações:
o Por exemplo, um gráfico de barras comparando quantas partidas cada time venceu no total.
o Charts de desempenho de jogadores (não trivial, mas possível com bibliotecas de chart).
* Feedback em tempo real para o público:
o Usar Supabase Realtime ou outra via para que quando uma partida é adicionada pelo admin, os espectadores que estão com a página aberta vejam atualizar sem dar refresh (WebSockets).
o Mostrar "AO VIVO" se uma partida/série está em andamento (admin poderia marcar status de em andamento).
* Dark mode toggle (shadcn/ui e Tailwind facilitam, só configurar se desejado).
* Detalhamento de Partidas:
* Permitir armazenar e mostrar estatísticas detalhadas de cada partida:
o Por exemplo, kills, pontos, placar (no caso de jogos de FPS ou MOBA, placar kill ou rounds). Isso exigiria mais campos nas tabelas (talvez tabelas específicas por jogo ou genéricas de stats).
o Upload de replay ou link do vídeo da partida (um campo URL).
* Página específica para cada partida (rota /partidas/[id]) mostrando detalhes e lineups daquela partida, comentários, etc.
* Interatividade para Usuários comuns:
* Embora atualmente só admins façam mudanças, poderíamos abrir a plataforma para que espectadores possam:
o Criar conta (sem ser admin) para comentar nas partidas, votar em MVP (se MVP fosse votação do público, por exemplo).
o Isso envolveria sistema de comentários ou enquetes, fugindo do escopo atual mas é possível.
* Ou permitir que jogadores (diferente de admins) tenham acesso para confirmar sua presença ou ver seu próprio desempenho login (isso precisaria accounts para jogadores, não apenas admin).
* Notificações e Integrações:
* Enviar notificações (email ou push) quando resultados forem publicados.
* Integração com Discord/Webhook: ex: após registrar uma partida, enviar uma mensagem num canal do Discord informando o resultado e MVP.
* Deploy do front-end possivelmente junto com um domínio próprio, e backend (Supabase) escalonado se o público crescer.
* Performance e Escalabilidade:
* Se os dados crescerem (vários campeonatos, muitos jogos), otimizar consultas com índices adequados no banco.
* Usar CDN para imagens e caching para páginas públicas (Next.js ISR para páginas como Home que não mudam a cada segundo; revalidar a cada X segundos ou on-demand triggers quando admin atualiza algo).
* Testes automatizados: escrever testes unitários para funções de cálculo (ex: dado certo conjunto de partidas, o ranking sai certo) e testes de integração para páginas (usando Playwright/ Cypress).
* Segurança Adicional:
* Refinar Row Level Security no Supabase:
o Ex: garantir que admin_rac só insere/atualiza partidas e jogadores do seu âmbito. Isso exigiria policies que checam o role e talvez o team_id do profile vs os dados sendo modificados.
o Auditar ações admin: manter um log de ações (quem inseriu qual resultado, quando) em caso de precisar verificar.
* Sanitização de inputs e verificar que não há vulnerabilidades XSS (Tailwind e React já ajudam, Supabase queries não envolvem SQL injection se usamos API).
* Atualizações tecnológicas:
* Manter o projeto atualizado com as versões futuras do Next.js, React e Tailwind.
* Shadcn/ui pode lançar componentes novos ou mudar algo; verificar changelogs e atualizar conforme necessário.
* Supabase pode introduzir novas funcionalidades úteis (ex: Supabase Functions/Edge Functions) que poderiam ser usados para logic server-side (por ex., computar ranking via RPC).
Em suma, a versão 2.0 poderia tornar o sistema mais genérico e interativo, mas a versão atual já estabelece uma base sólida. Priorize inicialmente cumprir todos os requisitos atuais, garantindo corretude dos dados e facilidade de uso para os admins. Depois, essas ideias futuras podem ser avaliadas conforme a direção que o projeto tomar. Boa codificação!

